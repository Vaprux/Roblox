--// Services & References
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// ESP Configuration
local ESP = {
    Enabled     = false,
    Boxes       = false,
    Names       = false,
    Tracers     = false,
    Players     = false,
    TeamMates   = false,

    BoxShift    = CFrame.new(0, -1.5, 0),
    BoxSize     = Vector3.new(4, 6, 0),
    AttachShift = 1,
    Thickness   = 2,

    Color       = Color3.fromRGB(255, 170, 0),
    TeamColor   = true,
    FaceCamera  = false,

    Objects     = setmetatable({}, { __mode = "kv" }),
    Overrides   = {}
}

--// Utility: Drawing Constructor
local function NewDrawing(class, props)
    local obj = Drawing.new(class)
    for prop, val in pairs(props) do
        obj[prop] = val
    end
    return obj
end

--// Helper Functions
function ESP:GetTeam(player)
    return self.Overrides.GetTeam and self.Overrides.GetTeam(player) or player and player.Team
end

function ESP:IsTeamMate(player)
    return self.Overrides.IsTeamMate and self.Overrides.IsTeamMate(player)
        or self:GetTeam(player) == self:GetTeam(LocalPlayer)
end

function ESP:GetColor(obj)
    local player = self:GetPlrFromChar(obj)
    return (self.Overrides.GetColor and self.Overrides.GetColor(obj))
        or (player and self.TeamColor and player.Team and player.Team.TeamColor.Color)
        or self.Color
end

function ESP:GetPlrFromChar(char)
    return self.Overrides.GetPlrFromChar and self.Overrides.GetPlrFromChar(char)
        or Players:GetPlayerFromCharacter(char)
end

function ESP:Toggle(bool)
    self.Enabled = bool and (self.Boxes or self.Names or self.Tracers)

    if not self.Enabled then
        for _, esp in pairs(self.Objects) do
            for _, v in pairs(esp.Components) do
                if v then v.Visible = false end
            end
        end
    end
end

--// ESP Box Class
local BoxBase = {}
BoxBase.__index = BoxBase

function BoxBase:Remove()
    ESP.Objects[self.Object] = nil
    for _, v in pairs(self.Components) do
        if v then v.Visible = false v:Remove() end
    end
end

function BoxBase:Update()
    if not self.PrimaryPart then return self:Remove() end

    local player = self.Player
    local visible = true

    -- Visibility Conditions
    if ESP.Overrides.UpdateAllow and not ESP.Overrides.UpdateAllow(self) then visible = false end
    if player and (not ESP.Players or (not ESP.TeamMates and ESP:IsTeamMate(player))) then visible = false end
    if not workspace:IsAncestorOf(self.PrimaryPart) and not self.RenderInNil then visible = false end
    if self.IsEnabled then
        visible = type(self.IsEnabled) == "function" and self.IsEnabled(self) or ESP[self.IsEnabled]
    end

    -- Hide if not visible
    if not visible then
        for _, v in pairs(self.Components) do if v then v.Visible = false end end
        return
    end

    -- Compute Data
    local color = self.Color or (self.ColorDynamic and self:ColorDynamic()) or ESP:GetColor(self.Object)
    local cf = ESP.FaceCamera and CFrame.new(self.PrimaryPart.Position, Camera.CFrame.Position) or self.PrimaryPart.CFrame
    local size, shift = self.Size, ESP.BoxShift

    -- Box corners
    local p1 = (cf * shift * CFrame.new( size.X/2,  size.Y/2, 0)).Position
    local p2 = (cf * shift * CFrame.new(-size.X/2,  size.Y/2, 0)).Position
    local p3 = (cf * shift * CFrame.new( size.X/2, -size.Y/2, 0)).Position
    local p4 = (cf * shift * CFrame.new(-size.X/2, -size.Y/2, 0)).Position
    local top = (cf * shift * CFrame.new(0, size.Y/2, 0)).Position
    local root = (cf * shift).Position

    -- Draw Components
    local comp = self.Components

    -- Box
    if ESP.Boxes and comp.Quad then
        local A, B, C, D = Camera:WorldToViewportPoint(p1), Camera:WorldToViewportPoint(p2), Camera:WorldToViewportPoint(p3), Camera:WorldToViewportPoint(p4)
        comp.Quad.Visible = A.Z > 0 or B.Z > 0 or C.Z > 0 or D.Z > 0
        if comp.Quad.Visible then
        comp.Quad.PointA = Vector2.new(B.X, B.Y)
        comp.Quad.PointB = Vector2.new(A.X, A.Y)
        comp.Quad.PointC = Vector2.new(C.X, C.Y)
        comp.Quad.PointD = Vector2.new(D.X, D.Y)
            comp.Quad.Color = color
        end
    elseif comp.Quad then
        comp.Quad.Visible = false
    end

    -- Name & Distance
    local topScreen, onScreen = Camera:WorldToViewportPoint(top)
    if ESP.Names and comp.Name and comp.Distance then
        comp.Name.Visible = onScreen
        comp.Distance.Visible = onScreen
        if onScreen then
            comp.Name.Position = Vector2.new(topScreen.X, topScreen.Y)
            comp.Name.Text = self.Name
            comp.Name.Color = color

            comp.Distance.Position = comp.Name.Position + Vector2.new(0, 14)
            comp.Distance.Text = math.floor((Camera.CFrame.Position - cf.Position).Magnitude) .. "m"
            comp.Distance.Color = color
        end
    else
        if comp.Name then comp.Name.Visible = false end
        if comp.Distance then comp.Distance.Visible = false end
    end

    -- Tracer
    if ESP.Tracers and comp.Tracer then
        local pos, ok = Camera:WorldToViewportPoint(root)
        comp.Tracer.Visible = ok
        if ok then
            comp.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / ESP.AttachShift)
            comp.Tracer.To = Vector2.new(pos.X, pos.Y)
            comp.Tracer.Color = color
        end
    elseif comp.Tracer then
        comp.Tracer.Visible = false
    end
end

--// Add ESP Box
function ESP:Add(object, props)
    if not object.Parent and not props.RenderInNil then return end
    if self:GetBox(object) then self:GetBox(object):Remove() end

    local esp = setmetatable({
        Object        = object,
        Name          = props.Name or object.Name,
        Color         = props.Color,
        Size          = props.Size or self.BoxSize,
        Player        = props.Player or Players:GetPlayerFromCharacter(object),
        PrimaryPart   = props.PrimaryPart or object:FindFirstChild("HumanoidRootPart"),
        IsEnabled     = props.IsEnabled,
        ColorDynamic  = props.ColorDynamic,
        RenderInNil   = props.RenderInNil,
        Components    = {}
    }, BoxBase)

    esp.Components.Quad     = NewDrawing("Quad",  { Thickness = self.Thickness, Transparency = 1, Filled = false, Visible = false })
    esp.Components.Name     = NewDrawing("Text",  { Center = true, Outline = true, Size = 19, Visible = false })
    esp.Components.Distance = NewDrawing("Text",  { Center = true, Outline = true, Size = 19, Visible = false })
    esp.Components.Tracer   = NewDrawing("Line",  { Thickness = self.Thickness, Transparency = 1, Visible = false })

    self.Objects[object] = esp

    object.AncestryChanged:Connect(function(_, parent)
        if not parent then esp:Remove() end
    end)

    local humanoid = object:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            esp:Remove()
        end)
    end

    return esp
end

function ESP:GetBox(obj)
    return self.Objects[obj]
end

--// Player Handling
local function OnCharacterAdded(character)
    local player = Players:GetPlayerFromCharacter(character)
    coroutine.wrap(function()
        local root = character:WaitForChild("HumanoidRootPart", 5)
        if root then
            ESP:Add(character, {
                Name        = player.Name,
                Player      = player,
                PrimaryPart = root
            })
        end
    end)()
end

local function OnPlayerAdded(player)
    player.CharacterAdded:Connect(OnCharacterAdded)
    if player.Character then
        OnCharacterAdded(player.Character)
    end
end

--// Initialization
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then OnPlayerAdded(player) end
end

Players.PlayerAdded:Connect(OnPlayerAdded)

--// Main Loop
RunService.RenderStepped:Connect(function()
    ESP.Enabled = ESP.Boxes or ESP.Names or ESP.Tracers
    if not ESP.Enabled then return end

    for _, esp in pairs(ESP.Objects) do
        pcall(function() esp:Update() end)
    end
end)

return ESP
